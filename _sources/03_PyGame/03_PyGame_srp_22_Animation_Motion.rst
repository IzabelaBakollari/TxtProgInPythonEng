Кретање цртежа
--------------

Анимације које смо до сада видели раде тако што у сваком фрејму приказују неку другу, унапред припремљену слику. Сада ћемо слике које приказујемо и померати, тако да се иста слика појављује на различитим местима у прозору, то јест креће се.

Погледајмо одмах пример:

.. activecode:: PyGame__anim_car_oneway_srp
    :nocodelens:
    :enablecopy:
    :modaloutput:
    :includesrc: src/PyGame/2_Animation/2b_Anim_Motion/car_rightwards_only_srp.py

Као и раније, имамо функцију *nov_frejm* која у сваком фрејму приказује неку слику. Оно што је ново у овом примеру је да се положај те слике мења из фрејма у фрејм. 

Слику приказујемо тако да се њен горњи леви угао појави у тачки (*auto_x*, *auto_y*). Да би се ауто кретао на десно, у сваком фрејму повећавамо *x* координату слике. При томе још само водимо рачуна да када ауто оде сувише десно, да вратимо ауто тако да се његов десни крај поравна са левом ивицом прозора. На тај начин ауто почиње постепено да се поново појављује са леве стране.

~~~~

На сличан начин можемо да померамо и цртеже које сами нацртамо (а не само готове слике). При томе слику или цртеж можемо да померамо у било ком смеру. Ево једног таквог примера:

.. activecode:: PyGame__anim_billiards_srp
    :nocodelens:
    :enablecopy:
    :modaloutput:
    :includesrc: src/PyGame/2_Animation/2b_Anim_Motion/billiards_srp.py

Обратите пажњу на то како проверавамо да ли је билијарска кугла дотакла неку ивицу екрана. Крајња десна тачка кугле има *x* координату једнаку :math:`cx+r`. Ако би та вредност постала једнака ширини прозора, то би значило да кугла додирује десну ивицу прозора, а ако је :math:`cx + r > sirina`, значи да је је кугла бар делом већ прошла десну ивицу прозора. У том случају наредбом  :math:`dx = -dx` постижемо да се од следећег фрејма *x* координати кугле додаје супротна вредност у односу на досадашњу, односно да се убудуће кугла помера за по 3 пиксела на лево. То ће изгледати као да се кугла одбила од десне ивице прозора. 

Приметимо још један детаљ: уместо :math:`cx + r > sirina` могли смо да користимо и :math:`cx + r >= sirina` и програм би радио скоро исто. Међутим, пошто се кугла **не помера за по један пиксел**, не би ваљало да смо користили услов :math:`cx + r == sirina`, јер би тада могло да се догоди да кугла прескочи положај који проверавамо и прође кроз ивицу прозора.

Детаљно смо анализирали случај десне ивице прозора, а исто размишљање је при писању програма примењено и на остале ивице. Укупни ефекат двеју *if* наредби је утисак да се кугла одбија од сваке ивице прозора.

Проверите да ли сте ово разумели тако што ћете одговорити на следећа питања.

Кретање цртежа - питања
'''''''''''''''''''''''

.. dragndrop:: pygame__anim_quiz_bounce1_srp
    :feedback: Покушај поново!
    :match_1: за леву ивицу ||| if cx - r < 0
    :match_2: за десну ивицу ||| if cx + r > sirina
    :match_3: за горњу ивицу ||| if cy - r < 0
    :match_4: за доњу ивицу ||| if cy + r > visina

    Повежите проверу да је кугла из претходног примера прошла одређену ивицу са одговарајућом *if* наредбом.

.. mchoice:: pygame__anim_quiz_bounce2_srp
    :answer_a: на десно
    :answer_b: на горе
    :answer_c: на лево
    :answer_d: на доле
    :correct: c
    :feedback_a: Покушајте поново
    :feedback_b: Покушајте поново
    :feedback_c: Тачно
    :feedback_d: Покушајте поново

    На коју страну се помера слика додавањем негативне вредности на њену *x* координату?

.. mchoice:: pygame__anim_quiz_bounce3_srp
    :answer_a: if x + sl_sirina < 0:
    :answer_b: if y + sl_visina < 0:
    :answer_c: if x < 0:
    :answer_d: if y < 0:
    :correct: b
    :feedback_a: Покушајте поново
    :feedback_b: Тачно
    :feedback_c: Покушајте поново
    :feedback_d: Покушајте поново

    Нека су димензије дате слике *sl_sirina* и *sl_visina*, а њен горњи леви угао (*x*, *y*). Како проверавамо да ли је слика у потпуности прошла кроз горњу ивицу прозора и више се не види ни један њен део?
    
.. dragndrop:: pygame__anim_quiz_bounce4_srp
    :feedback: Покушај поново!
    :match_1: слика је изашла кроз леву ивицу прозора ||| x + sl_sirina < 0
    :match_2: слика је почела да излази кроз леву ивицу прозора ||| x < 0
    :match_3: слика је изашла кроз десну ивицу прозора ||| x > sirina
    :match_4: слика је почела да излази кроз десну ивицу прозора ||| x + sl_sirina > sirina

    Нека је sirina ширина прозора, sl_sirina ширина слике, а (x, y) горњи леви угао слике. Повежите логичке услове са значењем.

.. mchoice:: pygame__anim_quiz_bounce5_srp
    :answer_a: x = sirina; dx = -10
    :answer_b: x = sirina + sl_sirina; dx = -10
    :answer_c: x = sirina - sl_sirina; dx = -10
    :answer_d: x = sirina + sl_sirina; dx = 10
    :correct: a
    :feedback_a: Тачно
    :feedback_b: Не, то је предалеко од десне ивице.
    :feedback_c: Не, тако је цела слика већ у прозору.
    :feedback_d: Не, слика је предалеко и још ће наставити да се удаљава.

    Нека је *sirina* ширина прозора, *sl_sirina* ширина слике, (*x*, *y*) горњи леви угао слике, а *dx* величина за коју ће се касније мењати *x* координата слике. Помоћу којих наредби ће слика почети да се појављује улазећи у прозор кроз десну ивицу?

Задатак - ауто који иде лево - десно
''''''''''''''''''''''''''''''''''''

Покушајте да преправите први програм, тако се ауто креће наизменично на једну па на другу страну, као у примеру (дугме "Покрени пример"). Програм већ садржи наредбе помоћу којих се формира торка од две слике. Слика аута који иде надесно се учитава, док се слика аута окренутог на другу страну добија функцијом *pg.transform.flip* која од дате слике прави симетричну.

.. activecode:: PyGame__anim_car_right_left_srp
    :nocodelens:
    :enablecopy:
    :modaloutput:
    :playtask:
    :includehsrc: src/PyGame/2_Animation/2b_Anim_Motion/car_right_left_srp.py
    
    auto_nadesno_slika = pg.image.load("car.png") 
    auto_nalevo_slika = pg.transform.flip(auto_nadesno_slika, True, False)
    auto_slike = (auto_nadesno_slika, auto_nalevo_slika)
