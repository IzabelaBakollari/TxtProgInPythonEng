Проблеми:

- Текст "тест" на дугмету за тестирање је исписан латиницом.
- Извршавање корак по корак не ради у локалу.

Рачунање
========

У претходном поглављу смо већ видели једноставне примере програма који прихватају неколико целих бројева и приказују њихов збир. Сада ћемо кроз неколико примера и задатка видети како се пишу и користе и друге рачунске операције и функције за рачунање са бројевима.


.. infonote::

    Почев од овог поглавља, уз неке програме појавиће се дугме на коме пише "тест". Кликом на ово дугме покрећете аутоматско тестирање на низу припремљених примера. Резултати тестирања ће се појавити испод вашег програма, у облику табеле.

    При аутоматском тестирању променљиве које представљају улазне вредности аутоматски ће добити вредности из теста, а променљива која се исписује биће упоређена са очекиваним резултатом. Да би овакво тестирање било могуће, наредбе улаза и излаза се не могу мењати, а нове наредбе улаза и излаза не треба писати. 
    
    Програме са аутоматским тестирањем можете да извршавате и на уобичајени начин, укључујући и извршавање корак по корак. Уколико желите да копирате цео програм (заједно са делом који не можете да мењате), користите дугме "Ископирај".

**Множење**

Као и у већини програмских језика, за операцију множења бројева се користи знак ``*``.

.. questionnote::

    **Задатак - Кречење**
    
    Припрема се кречење једне собе и потребно је израчунати површину плафона и укупну површину зидова. 
    
    Написати програм који учитава дужину, ширину и висину собе у метрима, а затим израчунава и исписује површину плафона и зидова.

.. activecode:: console_calc_walls
   :runortest: duzina, sirina, visina, plafon, zidovi
   :enablecopy:

   # -*- acsection: general-init -*-
   # -*- acsection: var-init -*-
   duzina, sirina, visina = map(float, input('Унесите димензије: ').split())
   # -*- acsection: main -*-
   plafon = 0      # ispravite ovaj red
   zidovi = 0      # ispravite ovaj red
   # -*- acsection: after-main -*-
   print(plafon, zidovi)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
          for d, s, v, p, z in [(4, 3, 2.5, 12, 35), (5.5, 5.5, 4, 30.25, 88)]:
            self.assertAlmostEqual(acMainSection(duzina = d, sirina = s, visina = v)["plafon"],p,5, "За улаз (%f %f %f) добија се површина плафона %f." % (d, s, v, p))
            self.assertAlmostEqual(acMainSection(duzina = d, sirina = s, visina = v)["zidovi"],z,5, "За улаз (%f %f %f) добија се површина зидова %f." % (d, s, v, z))
   myTests().main()
   
.. reveal:: walls_reveal
   :showtitle: Прикажи решење
   :hidetitle: Сакриј решење

   Дат је комплетан програм, можете и овде да га испробате.
	       
   .. activecode:: console_calc_walls_solution

       duzina, sirina, visina = map(float, input('Унесите димензије: ').split())
       plafon = duzina * sirina
       zidovi = 2*(duzina + sirina) * visina
       print(plafon, zidovi)

**Одузимање и дељење**

За операције одузимања и дељења Пајтон користи уобичајене ознаке, ``-`` за одузимање, а **/** за дељење.
      
.. questionnote::

    **Задатак - Географске координате у облику за GPS**
    
    Нашли сте стару мапу закопаног блага и са ње очитали координате блага у степенима, минутима и секундама, али ваш GPS уређај подржава само географске координате као реалне бројеве степени. 
    
    Напишите програм који за дату координату у степенима, минутима и секундама исписује реалан број степени.

Програм је скоро сасвим написан. Потребно је још додати израз ра рачунање реалног броја степени. Да бисмо (угловне) минуте претворили у степене, делимо их са :math:`60`, а секунде претварамо у степене дељењем са :math:`60\cdot60=3600`.

.. activecode:: console_calc_GPS_1
   :runortest: stepeni, minuti, sekunde, realni_stepeni
   :enablecopy:

   # -*- acsection: general-init -*-
   # -*- acsection: var-init -*-
   stepeni = int(input())
   minuti = int(input())
   sekunde = int(input())
   # -*- acsection: main -*-
   realni_stepeni = 0      # ispravite ovaj red
   # -*- acsection: after-main -*-
   print(realni_stepeni)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
          for d, m, s, df in [(14, 30, 0, 14.5), (0, 30, 1800, 1), (1, 2, 3, 1.03416666667)]:
            self.assertAlmostEqual(acMainSection(stepeni = d, minuti = m, sekunde = s)["realni_stepeni"],df,5, "За улаз (%d %d %d) добија се излаз %d." % (d, m, s, df))
   myTests().main()
   
.. reveal:: GPS_1_reveal
   :showtitle: Прикажи решење
   :hidetitle: Сакриј решење

   И ово решење можете одмах да испробате.
	       
   .. activecode:: console_calc_GPS_1_solution

       stepeni = int(input())
       minuti = int(input())
       sekunde = int(input())
       realni_stepeni = stepeni + minuti / 60 + sekunde / (60 * 60)
       print(realni_stepeni)

  
.. questionnote::

    **Задатак - Географске координате у облику за стару мапу**
    
    Пошто сте схватили да је стара мапа из претходног задатка била нечија шала, решили сте да и ви некоме приредите сличну шалу. Изабрали сте место у близини и очитали координате са вашег GPS уређаја. Сада вам је потребно да координате са уређаја у реалним степенима претворите у целе степене, минуте и секунде, да бисте направили одговарајућу "стару" мапу. 
    
    Довршите започети програм који обавља ово претварање.


.. activecode:: console_calc_GPS_2
    :runortest: realni_st, celi_st, celi_min, cele_sek
    :enablecopy:

    # -*- acsection: general-init -*-
    # -*- acsection: var-init -*-
    realni_st = float(input())
    # -*- acsection: main -*-
    def st_min_sek(realni_stepeni):
        celi_stepeni = 0   # ispravite ovaj red
        realni_minuti = 0  # ispravite ovaj red
        celi_minuti = 0    # ispravite ovaj red
        realne_sekunde = 0 # ispravite ovaj red
        cele_sekunde = 0   # ispravite ovaj red
        return celi_stepeni, celi_minuti, cele_sekunde

    celi_st, celi_min, cele_sek = st_min_sek(realni_st)
    # -*- acsection: after-main -*-
    print(celi_st, celi_min, cele_sek)
    ====
    from unittest.gui import TestCaseGui
    class myTests(TestCaseGui):
        def testOne(self):
            for df, d, m, s, in [(14.5, 14, 30, 0), (1, 1, 0, 0), (1.034167, 1, 2, 3)]:
                self.assertEqual(acMainSection(realni_st=df)["celi_st"], d, "За улаз %f број степени je %d." % (df, d))
                self.assertEqual(acMainSection(realni_st=df)["celi_min"], m, "За улаз %f број минута je %d." % (df, m))
                self.assertEqual(acMainSection(realni_st=df)["cele_sek"], s, "За улаз %f број секунди je %d." % (df, s))
    myTests().main()


.. reveal:: GPS_2_reveal
   :showtitle: Прикажи решење
   :hidetitle: Сакриј решење

   Ево једног могућег решења:
	       
   .. activecode:: console_calc_GPS_2_solution

        realni_st = float(input())
        def st_min_sek(realni_stepeni):
            celi_stepeni = int(realni_stepeni)
            realni_minuti = (realni_stepeni - celi_stepeni) * 60
            celi_minuti = int(realni_minuti)
            realne_sekunde = (realni_minuti - celi_minuti) * 60
            cele_sekunde = int(realne_sekunde + 0.5)
            return celi_stepeni, celi_minuti, cele_sekunde

        celi_st, celi_min, cele_sek = st_min_sek(realni_st)
        print(celi_st, celi_min, cele_sek)

.. infonote::

    У пајтону функција може да врати шише од једне вредности. У претходном задатку смо управо имали прилику да видимо како се ова могућност једноставно и природно користи. Наиме, у функцији се у *return* наредби просто наведе више вредности раздвојених зарезима, а на месту позива се резултат функције додељује групи вредности на исти начин.
    
    Ова корисна особина је иначе прилично ретка међу програмским језицима.
    
**Степеновање**

Осим 4 основне рачунске радње, може да нам затреба и степеновање. У Пајтону се степеновање означава са две звездице ``**``.

.. questionnote::
    
    **Пример - акваријум**
    
    Колико литара воде је потребно да се напуни акваријум облика коцке ивице *a*? 
    
    Један литар је исто што и кубни дециметар.

.. activecode:: console_calc_aquarium1

    a = float(input("Колика је страница акваријума (у дециметрима): "))
    print("Потребно је %f литара воде." % a**3)

Нема много смисла број литара за акваријум исписивати на више од две децимале (нико неће мерити воду за акваријум у милилитрима). 

.. infonote::

    Када задајемо опис ``%f`` за реалан број, можемо да задамо колико укупно места желимо да одвојимо за исписивање тог броја, као и колико децимала ће да буде исписано. На пример ``%8.2f`` значи укупно 8 места, са исписивањем две децимале. 
    
    Ако је задати број места већи од потребног, биће додати размаци на почетак исписа. Ово је врло практично када исписујемо бројеве различите величине један испод другог, јер ће бројеви бити прегледно "потписани".
    
    Ако задати укупан број места није довољан, биће заузето онолико места колико је потребно.
    
Како овде желимо да број заузме тачно онолико места колико му треба (не желимо празнину испред броја), задаћемо 0 за укупан број места за испис:


.. activecode:: console_calc_aquarium2

    a = float(input("Колика је страница акваријума (у дециметрима): "))
    print("Потребно је %0.2f литара воде." % a**3)

**Квадратни корен и апсолутна вредност**

``додати задатке за решавање: а) растојање на путу између два мајлстоуна, и б) растојање у равни``


**Целобројно дељење и заокруживање**

Понекад је уместо тачне вредности количника два броја, потребно израчунати само целобројни део количника. На пример, може да нас занима колико флашица од пола литра можемо да напунимо са 2.7 литара исцеђеног сока. Тачан количник добијамо користећи реално дељење (операција ``/``), а целобројни део количника добијамо такозваним целобројним дељењем (операција ``//``). Остатак при целобројном дељењу се добија као резултат операције означене са ``%``.

.. activecode:: console_calc_q_float1

    print("Са 2.7 литара сока напунићемо", 2.7/0.5, "флашица од пола литра.")
    print("То је", 2.7//0.5, "пуних флашица, и још", 2.7%0.5, "литра у последњој флашици.")

Цели део реалног броја може да се добије и применом математичке функције ``floor()``, која врши заокруживање свог аргумента наниже, то јест на најблиђи мањи (или једнак) цео број. Заокруживање навише се постиже функцијом ``ceil()``. Обе функције су део модула ``math``, који је потребно укључити у програм да би ове функције могле да се користе. 

.. activecode:: console_calc_q_float2

    import math
    print("Са 2.7 литара сока добићемо", math.floor(2.7/0.5), "пуних флашица од пола литра.")
    print("Укупно ће нам требати", math.ceil(2.7/0.5), "флашица.")

``Део са грешком заокруживања (који следи) можда треба прећутати?``

Са заокруживањем бројева треба бити опрезан, јер се понекад могу добити погрешни резултати:
    
.. activecode:: console_calc_q_rounderror1

    import math
    print("       0.3 / 0.1 =", 0.3 / 0.1)
    print("floor(0.3 / 0.1) =", math.floor(0.3 / 0.1))
    print("      0.3 // 0.1 =", (0.3 // 0.1))
    
Видимо да је овде од израза 0.3/0.1 чија је вредност 3, заокруживањем наниже добијен резултат 2. Зашто се то догодило?

Испишимо већи број децимала израчунатог количника:

.. activecode:: console_calc_q_rounderror2

    import math
    print("0.3 / 0.1 = %0.20f" % (0.3 / 0.1))

Вероватно видите грешку на шеснаестој децимали. Ова малецка грешка се појављује само за неке бројеве, а због тога што рачунари нису у могућности да потпуно тачно памте сваки реалан број. Овако мала грешка најчешће не ствара никакве проблеме и пролази неопажено. Међутим, код узимања целог дела и најмања грешка је довољна да резултат буде погрешан цео број.

Овај проблем је у вези са тиме како рачунари раде и испољава се у практично свим програмским језицима, без обзира на то колико простора се одваја за памћење реалних бројева (са више одвојеног простора исти проблем би се појавио на некој каснијој децимали). 

Проблем се може заобићи коришћењем функције *round()*, којом се дати реалан број заокружује на одређени број децимала. Функција *round()* у Пајтону може да има један или два аргумента. Први аргумент је број који заокружујемо, а други, ако постоји, говори на колико децимала заокружујемо. Ако другог аргумента нема, подразумева се нула, то јест заокруживање на најближи цео број.

Како сада да употребимо функцију *round()*, да бисмо избегли описани проблем? То углавном зависи од контекста и тачности која нам је потребна у задатку који решавамо. На примеру сипања сока, можемо да сматрамо да је флашица пуна ако је у њу стало више од 0.9995 њеног капацитета (није битно ако недостаје делић милилитра). У том случају је довољно да заокружимо реалан број флашица на три децимале пре узимања целог дела.

.. activecode:: console_calc_q_rounderror3

    import math
    vf = float(input("Колика је запремина флаше: "))
    vs = float(input("Колико има сока: "))
    br_flasica = round(vs/vf, 3)
    print("Добићемо", math.floor(br_flasica), "пуних флашица.")
    print("Укупно ће нам требати", math.ceil(br_flasica), "флашица.")
