Скупови
=======

Са скуповима смо се вероватно сви срели још у првим разредима школе на часовима математике. Сада ћемо проћи кроз неке примене скупова у програмирању.

Пајтон подржава уобичајене операције са скуповима као у математици, само су ознаке другачије:

==========================  =======================   =======================
Операција                   Математика                Пајтон                 
==========================  =======================   =======================
Пресек                      :math:`A \cap       B`    A & B                  
Унија                       :math:`A \cup       B`    A | B                  
Разлика                     :math:`A \setminus  B`    A - B                  
Симетрична разлика          :math:`A \triangle  B`    A ^ B                  
==========================  =======================   =======================

.. image:: ../../_images/console_sets.jpg
    :width: 600px   
    :align: center

Ево како то изгледа и у програму:

.. activecode:: sets__operators
    
    a = {1, 2, 3}
    b = {3, 4, 5}
    print('A = %r, B = %r' % (a, b))
    print('%r & %r = %r' % (a, b, a & b), '(пресек скупова)')
    print('%r | %r = %r' % (a, b, a | b), '(унија скупова)')
    print('%r - %r = %r' % (a, b, a - b), '(разлика скупова)')
    print('%r ^ %r = %r' % (a, b, a ^ b), '(симетрична разлика скупова)')

Ево како се пишу провере да ли је нешто елемент или подскуп другог скупа:

==========================  =======================   =======================
Релација                    Математика                Пајтон                 
==========================  =======================   =======================
припада (је елемент)        :math:`A \in B`            A in B                 
је подскуп                  :math:`A \subseteq B`      A <= B                 
је прави подскуп            :math:`A \subset B`        A < B                  
је надскуп                  :math:`A \supseteq B`      A >= B                 
је прави надскуп            :math:`A \supset B`        A > B                  
==========================  =======================   =======================

.. activecode:: sets__comparison
    
    def test_podskup(x, y):
        if x == y:
            print('Скупови %r и %r су једнаки' % (x, y))
        elif x < y:
            print('Скуп %r је подскуп скупа %r' % (x, y))
        elif x > y:
            print('Скуп %r је надскуп скупа %r' % (x, y))
        else:
            print('Скуп %r није ни подскуп ни надскуп скупа %r' % (x, y))
            
    a, b, c = {1, 2, 3}, {3, 4, 5}, {3, 4}
    print('A = %r, B = %r, C = %r' % (a, b, c))
    test_podskup(a^b, (a|b)-(a&b))
    test_podskup(c, b)
    test_podskup(a, a - b)
    test_podskup(a, b)
    
    if 3 in b:
        print('%r је елемент скупа %r' % (3, b))
    else:
        print('%r није елемент скупа %r' % (3, b))

Већ смо видели да скупове можемо да наводимо директно у програму, као :math:`\{1, 2, 3\}`. Осим бројева, скуп може да као своје елементе садржи и друге непроменљиве објекте, као што су торке или стрингови. Празан скуп :math:`\emptyset` пишемо као ``set()``. 

Осим формирања скупова директним навођењем елемената или израчунавањем, израз *x* неког од стадардних типова (као што је стринг, листа или речник), можемо лако да претворимо у скуп тако што пишемо *set(x)*. Пошто скуп не може да садржи више једнаких елемената, на овај начин задржавамо само различите елементе из *x*.

.. activecode:: sets__distinct_elements
    
    def razliciti(sta, x):
        print('%s %r има %d елемената, од тога %d различитих.' % (sta, x, len(x), len(set(x))))
        print('Различити елементи су: %r' % set(x))
        print()
        
    razliciti('Стринг', 'АБРАКАДАБРА')
    razliciti('Листа', [1, 2, 3, 1, 4, 2, 5, 3, 4, 6, 5, 6])
    razliciti('Торка', (1, 2, 3, 1, 4, 2, 5, 3, 4, 6, 5, 6) )
    razliciti('Речник', {'a': 1, 'b':2, 'c':5})
    razliciti('Опсег', range(5))

.. questionnote::

    **Задатак - разлчичити бројеви**
    
    За низ целих бројева унетих у једном реду (раздвојених размацима), исписати да ли су сви ти бројеви различити.
    
Да бисте довршили дати програм, потребно је да напишете одговарајући услов у *if* наредби:

.. activecode:: sets__are_all_distinct

    a = map(int, input().split()) # unos niza celih brojeva
    if True: # zamenite True ispravnim izrazom
        print('Сви бројеви су различити')
    else:
        print('Међу датим бројевима има једнаких')
        

.. reveal:: sets__are_all_distinct_reveal
   :showtitle: Решење
   :hidetitle: Сакриј решење
   
   Недовршени ред програма може да гласи овако:
   
    .. activecode:: sets__are_all_distinct_solution
        :passivecode: true
          
        if len(a) == len(set(a)):
   
.. questionnote::

    **Задатак - понављање речи**

    Дате су две реченице без знакова интерпункције, свака у по једном реду. Исписати колико различитих речи се појављује у обе реченице, а затим исписати и те речи (у било ком редоследу без понављања).
    
    На пример, за реченице: "зрно по зрно погача програм по програм програмер" и "програм по програм два програма", треба исписати број 2 и текст "по програм" или "програм по".

Покушајте да поправите дати програм, тако што ћете написати израз за рачунање траженог скупа речи:

.. activecode:: sets__distinct_in_intersection

    a = input().split()
    b = input().split()
    presek = set() # ispravite ovaj red
    print(len(presek))
    for rec in presek:
        print(rec, end = ' ')
    print()

.. reveal:: sets__distinct_in_intersection_reveal
   :showtitle: Решење
   :hidetitle: Сакриј решење
   
    Недовршени ред програма може да гласи овако:
   
    .. activecode:: sets__distinct_in_intersection_solution
        :passivecode: true

        presek = set(a) & set(b)

У следећем задатку биће потребно да напишете неке сложене изразе за израчунавање скупова:

.. questionnote::

    **Задатак - ко све одговара опису**
    
    У комшилуку има осморо деце која су често заједно. Њихова имена су: Ана, Бане, Вера, Горан, Дуња, Ђорђе, Ема и Жарко. 
    
    Ана, Бане, Вера и Горан иду на програмерску секцију, а Ана, Бане, Дуња и Ђорђе на спортску секцију.
    
    Напишите програм који израчунава и приказује одговоре на следећа питања:
    
    - Ко су дечаци који иду на бар једну секцију?
    - Ко су девојчице које се не баве спортом?
    - Ко је девојчица која се бави спортом али не и програмирањем?
    
Покушајте да довршите програм додавањем израза за тражене скупове.

.. activecode:: sets__who_is_described_1
    
    sva_deca = {'Ана', 'Бане', 'Вера', 'Горан', 'Дуња', 'Ђорђе', 'Ема', 'Жарко'}
    programeri = {'Ана', 'Бане', 'Вера', 'Горан'}
    devojcice = {'Ана','Вера','Дуња','Ема'}
    sportisti = {'Ана', 'Бане', 'Дуња', 'Ђорђе'}
    
    decaci = sva_deca - devojcice
    bar_jedna_sekcija = set() # popravite naredbu
    decaci_sa_bar_jedne_sekcije = set() # popravite naredbu
    
    devojcice_nesportisti = set() # popravite naredbu
    
    devojcica_sport_neprog = set() # popravite naredbu

    print(decaci_sa_bar_jedne_sekcije)
    print(devojcice_nesportisti)
    print(devojcica_sport_neprog)

.. reveal:: sets__who_is_described_1_reveal
   :showtitle: Решење
   :hidetitle: Сакриј решење
   
    Изрази који недостају у програму су могли бити написани овако:
    
    .. activecode:: sets__who_is_described_1_solution
        :passivecode: true
        
        bar_jedna_sekcija = programeri | sportisti
        decaci_sa_bar_jedne_sekcije = decaci & bar_jedna_sekcija
        
        devojcice_nesportisti = devojcice & (sva_deca - sportisti)
        
        devojcica_sport_neprog = devojcice & sportisti & (sva_deca - programeri)

    Приметимо да је и скуп дечака који иду на бар једну секцију могао да буде израчунат у једној наредби:    
    
    .. activecode:: sets__who_is_described_1_solution_2
        :passivecode: true
        
        decaci_sa_bar_jedne_sekcije = (sva_deca - devojcice) & (programeri | sportisti)


Неко би можда уместо целог претходног програма написао само:

.. activecode:: sets__who_is_described_1_solution_3

    print('Бане', 'Горан', 'Ђорђе')
    print('Вера', 'Ема')
    print('Дуња')
    
Тиме добијамо програм који испипсује оно што се тражило, али промашујемо поенту. Компјутери треба да ослободе рачунања нас, а не ми њих. У реду, можда је ово било лакше израчунати напамет него испрограмирати, али кроз овакве примере постепено учимо да испрограмирамо и нешто што се не може израчунати напамет. На пример, задатак је могао да гласи и овако:

.. questionnote::

    **Пример - ко одговара опису (друга верзија)**
    
    У комшилуку има осморо деце која су често заједно. Њихова имена су: Ана, Бане, Вера, Горан, Дуња, Ђорђе, Ема и Жарко. 
    
    Ана, Бане, Вера и Горан иду на програмерску секцију, а Ана, Бане, Дуња и Ђорђе се баве спортом. 
    
    Напишите програм који добија опис једног детета тако што постави питања: 
    
    - да ли је то девојчица
    - да ли је програмер 
    - да ли је спортиста
    
    а корисник одговори на нека или сва од ових питања. Програм затим треба да испише имена све деце која одговарају опису. 
    
    Питања на која се не добије одговор се не узимају у обзир. На пример, за одговоре 'да', 'не' и '-' редом, опису одговарају девојчице које нису програмери, а то су Дуња и Ема.
    
Ево како бисмо у том случају могли да решимо задатак:

.. activecode:: sets__who_is_described_2
    
    def filtriraj(skup, pitanje, filtar):
        uputstvo = '("д" за ДА, "н" за НЕ, све остало за НЕ ЗНАМ) '
        odgovor = input(pitanje + uputstvo).lower()
        if odgovor == 'д' or odgovor == 'd' :
            return skup & filtar
        elif odgovor == 'н' or odgovor == 'n':
            return skup & (sva_deca - filtar)
        else:
            return skup

    sva_deca = {'Ана', 'Бане', 'Вера', 'Горан', 'Дуња', 'Ђорђе', 'Ема', 'Жарко'}
    programeri = {'Ана', 'Бане', 'Вера', 'Горан'}
    devojcice = {'Ана','Вера','Дуња','Ема'}
    sportisti = {'Ана', 'Бане', 'Дуња', 'Ђорђе'}

    to_mogu_biti = sva_deca
    to_mogu_biti = filtriraj(to_mogu_biti, 'Да ли је девојчица? ', devojcice)
    to_mogu_biti = filtriraj(to_mogu_biti, 'Да ли је програмер? ', programeri)
    to_mogu_biti = filtriraj(to_mogu_biti, 'Да ли је спортиста? ', sportisti)

    if len(to_mogu_biti) == 1:
        (dete,) = to_mogu_biti
        print('То је', dete)
    else:
        for dete in to_mogu_biti:
            print('То може бити', dete)

Овде смо исписивање успут учинили нешто лепшим, без заграда које означавају скупове. Додатно, када само једно дете одговара опису (скуп *to_mogu_biti* има један елемент), можемо да кажемо "То је" уместо "То може бити". Иако скуп има само један елемент, могли смо и у том случају да користимо *for* петљу (редови 22 и 23 програма). Уместо тога, користили смо распакивање једночланог скупа у неименовану једночлану торку да бисмо променљивој *dete* доделили вредност јединог елемента скупа.

.. questionnote::

    **Задатак - панграми**
    
    У следећем програму је дата листа реченица (преузета са википедије). Довршити програм тако да проналази реченице које нису панграми, ако таквих има.
    
.. infonote::

    **Објашњење:** Панграм је реченица која садржи сва слова неког алфабета. 
    
    Осим што су популарни међу енигматичарима, панграми су корисни за илустровање фонтова, када у кратком тексту треба приказати изглед свих слова неког алфабета.
    
Да бисмо проверили да ли је нека реченица панграм, можемо у тој реченици да издвојимо слова од осталих знакова тако што нађемо пресек скупа свих знакова реченице и скупа свих слова азбуке. Ако скуп слова реченице има 30 елемената, значи да реченица (поред других могућих знакова) садржи сва слова азбуке, односно да је панграм. 

У следећем програму је потребно само довршити започету функцију.

.. activecode:: sets__pangram
    
    # je_pangram(recenica) vraca True ako je recenica pangram (a False ako nije)
    def je_pangram(recenica):
        sva_slova = set("абвгдђежзијклљмнњопрстћуфхцчџш")
        return True # dovrsite funkciju

    recenice = [
        "Фијуче ветар у шибљу, леди пасаже и куће иза њих и гунђа у оџацима.",
        "Ниџо, чежњиво гледаш фотељу, а Ђура и Мика хоће позицију себи.",
        "Дебљој згужвах смеђ филц — њен шкрт џепчић.",
        "Вук Његошу: „Не ломи џабе перо, дођи тићу, чије се фаце зажељех”.",
        "Људи, јазавац Џеф трчи по шуми глођући неко суво жбуње.",
        "Боја ваше хаљине, госпођице Џафић, тражи да за њу кулучим.",
        "Хаџи Ђера је заћутао и бацио чежњив поглед на шољу с кафом.",
        "Џабе се зец по Хомољу шуња, чувар Јожеф лако ће и ту да га нађе.",
        "Оџачар Филип шаље осмехе туђој жени, а његова кућа без деце.",
        "Џајић одскочи у аут и избеже ђон халфа Пецеља и његов шамар.",
        "Пламте оџаци фабрика а чађаве гује се из њих дижу и шаљу ноћ.",
        "Ајшо, лепото и чежњо, за љубав срца мога, дођи у Хаџиће на кафу.",
        "Љубазни фењерџија чађавог лица хоће да ми покаже штос."
    ]

    for recenica in recenice:
        if not je_pangram(recenica):
            print('Реченица: "', recenica, '" није панграм.')

.. reveal:: sets__pangram_reveal
   :showtitle: Решење
   :hidetitle: Сакриј решење

    Функција je_pangram, која враћа одговор на питање да ли је дата реченица панграм, може да се напише овако:
   
    .. activecode:: sets__pangram_solution_1
       :passivecode: true
    
       def je_pangram(recenica):
           sva_slova = set("абвгдђежзијклљмнњопрстћуфхцчџш")
           slova_u_recenici = set(recenica.lower()) & sva_slova
           return 30 == len(slova_u_recenici)
   
Након што сте решили задатак, или искористили понуђено решење, можда ће вас интересовати зашто исписана реченица није панграм. Уместо да пажљиво прегледамо слова те реченице и тражимо које слово недостаје, можемо да преправимо програм, тако да за реченице које нису панграми испише и која им слова недостају.

Функцију *je_pangram* ћемо да заменимо врло сличном функцијом *nedostajuca_slova*, која уместо логичке вредности враћа скуп слова која се не појављују у реченици (ако је реченица панграм, функција враћа празан скуп).

.. activecode:: sets__pangram_solution_2

    def nedostajuca_slova(recenica):
        sva_slova = set("абвгдђежзијклљмнњопрстћуфхцчџш")
        slova_u_recenici = set(recenica.lower()) & sva_slova
        return sva_slova - slova_u_recenici

    recenice = [
        # убаците овде реченице које желите да проверите
    ]
    
    sve_su_pangrami = True
    for recenica in recenice:
        slova_kojih_nema = nedostajuca_slova(recenica)
        if len(slova_kojih_nema) > 0:
            print('Реченица: "', recenica, '" није панграм, јер нема слова ', slova_kojih_nema, '.')
            sve_su_pangrami = False
            
    if sve_su_pangrami:
        print('Све дате реченице су панграми')
        
~~~~

Следи још један пример употребе скупова ради пребројавања различитих елементата неке колекције.

.. questionnote::

    **Задатак - да ли се даме нападају**
    
    Дате су позиције 8 дама на шаховској табли. Проверити да ли се неке две даме нападају (нападају се ако су у истом реду, колони или дијагонали табле).
    
    Позиције су дате у једном реду, раздвојене зарезима. Свака позиција је дата у шаховској нотацији и представља једно од 64 поља шаховске табле. На пример, доње лево поље се задаје као 'a1', горње лево као 'a8' итд (види леву слику).
    
    Један пример распореда при коме се даме не нападају је 'a2 b4 c6 d8 e3 f1 g7 h5', као на десној слици (распоред при коме се даме нападају ћете лако наћи).

    .. image:: ../../_images/chess_queens.jpg
        :width: 800px   
        :align: center

У недовршеном програму који следи, користе се листе *kolone* и *redovi*. Листа *kolone* садржи редне бројеве колона, а *redovi* редне бројеве редова у којима се даме налазе (броји се од нуле). Следећа слика за свако поље показује прво редни број његове колоне, а затим врсте:

.. image:: ../../_images/chess_xy.jpg
    :width: 400px   
    :align: center

Да бисмо проверили да ли се све даме налазе у различитим колонама и у различитим редовима, довољно је да проверимо да ли поменуте две листе имају по осам различитих елемената (тај део смо препустили вама).

Како још да проверимо да ли су даме на различитим дијагоналама? 

- Погледајмо пажљивије бројчане координате поља најдуже црне дијагонале и њој паралелних дијагонала. Видимо да су координате на најдужој црној дијагонали једнаке. На њој суседним, белим дијагоналама од по седам поља, координате се на сваком пољу дијагонале разликују за 1 (на дијагонали изнад је ред већи од колоне за 1, а на дијагонали испод обрнуто). Гледајући и остале дијагонале у смеру /, можемо да приметимо да се на свакој таквој дијагонали разлика координата не мења.
- Посматрајући најдужу белу дијагоналу, можемо да приметимо да је на свим њеним пољима збир координата једнак 7. На пољима било које дијагонале паралелне са њом (дијагонале у смеру \\) збир је неки други, али је на свим пољима дијагонале исти.

Закључујемо да се даме налазе на различитим дијагоналама ако поља на којима су даме имају различите збирове координата и различите разлике координата. Зато ћемо да формирамо листу *dijag1* са збировима и листу *dijag2* са разликама координата поља на којима се налазе даме. Сада је провера да ли су све даме на различитим дијагоналама врло слична провери за врсте и колоне.

.. activecode:: sets__chess_queens
    
    dame = input('На којим пољима су даме? ').split()
    kolone = [ord(dama[0])-ord('a') for dama in dame]
    redovi = [ord(dama[1])-ord('1') for dama in dame]
    dijag1 = [red + kolona for red, kolona in zip(redovi, kolone)]
    dijag2 = [red - kolona for red, kolona in zip(redovi, kolone)]
    if True: # ispravite naredbu
        print('Не нападају се')
    else:
        print('Нападају се')

.. reveal:: sets__chess_queens_reveal
   :showtitle: Решење
   :hidetitle: Сакриј решење
   
   Наредба коју је требало допунити може да се напише на пример овако:

    .. activecode:: sets__chess_queens_solution_1
        :passivecode: true
        
        if (len(set(redovi)) == 8 and len(set(kolone)) == 8 and
           len(set(dijag1)) == 8 and len(set(dijag2)) == 8):
        
    или овако:
    
    .. activecode:: sets__chess_queens_solution_2
        :passivecode: true
        
        if min(len(set(redovi)), len(set(kolone)), 
            len(set(dijag1)), len(set(dijag2))) == 8:

И за крај поглавља о скуповима, нешто тежи задатак, у коме се комбинује употреба скупова са речницима.

.. questionnote::

    **Пример - тагови**
    
    За сваку од наведених особа, дат је списак неких појмова у вези са том особом. То може бити град у коме особа живи, омиљено јело, спорт, или било шта друго. На пример:

    - Петар: Београд, програмирање, фудбал, пљескавица, италијански
    - Милош: Нови Сад, физика, кошарка, колачи, немачки, енглески
    - Ана: Краљево, математика, одбојка, малине, енглески, руски
    - Љубица: Ужице, клавир, кошарка, салата, енглески
    - Јован: Шабац, виолина, рукомет, сарма, шпански, енглески
    
    Написати програм који омогућава кориснику да зада списак појмова раздвојених зарезима, и да добије листу особа уређену по броју поклапања са листом коу је задао (најпре највише поклапања). На тај начин би корисник на пример могао да наведе нека своја интерсовања или особине и да види колико има заједничког са сваком од датих особа.
    
    На пример, ако за особе из примера задамо појмове **кошарка, енглески, Нови Сад**, треба да добијемо списак:
    
    Милош 3
    
    Љубица 2
    
    Ана 1
    
    Јован 1
    
    Петар 0

    
Кључно место у задатку је да се за сваку особу израчуна колико од задатих појмова се појављује и у списку те особе. Ове резултате можемо да држимо у речнику, чији су кључеви особе, а вредности број поклапања.

Један начин да решимо проблем је да у двострукој петљи по задатим појмовима и особама проверавамо да ли је текући појам у списку појмова текуће особе. При потврдном одговору повећавамо одговарајући бројач у речнику.

.. activecode:: sets__tags_1

    tagovi_za_osobu = {
        'Петар': {'Београд', 'програмирање', 'фудбал', 'пљескавица', 'италијански'},
        'Милош': {'Нови Сад', 'физика', 'кошарка', 'колачи', 'немачки', 'енглески'},
        'Ана': {'Краљево', 'математика', 'одбојка', 'малине', 'енглески', 'руски'},
        'Љубица': {'Ужице', 'клавир', 'кошарка', 'салата', 'енглески'},
        'Јован': {'Шабац', 'виолина', 'рукомет', 'сарма', 'шпански', 'енглески'}
    }

    poklapanje = {}
    for osoba in tagovi_za_osobu.keys():
        poklapanje[osoba] = 0
        
    tagovi = input('Наведите појмове који вас интерсују раздвојене зарезима: ').split(',')
    for tag in tagovi:
        for osoba in tagovi_za_osobu.keys():
            if tag.strip() in tagovi_za_osobu[osoba]:
                poklapanje[osoba] += 1
                
    sve_osobe = sorted(list(poklapanje), key = lambda x: -poklapanje[x])
    for osoba in sve_osobe:
        print(osoba, poklapanje[osoba])

``Коментар: ламбда функција``

Други, нешто краћи начин, који је више у духу Пајтона: уместо да бројимо поклапање за сваку особу и сваки појам посебно, можемо да свакој особи придружимо дужину пресека њених појмова са списком тражених појмова. Такође, уместо листе кључева, сортирамо целе ставке из речника као парове (торке од два елемента - кључ и вредност).

.. activecode:: sets__tags_2

    tagovi_za_osobu = {
        'Петар': {'Београд', 'програмирање', 'фудбал', 'пљескавица', 'италијански'},
        'Милош': {'Нови Сад', 'физика', 'кошарка', 'колачи', 'немачки', 'енглески'},
        'Ана': {'Краљево', 'математика', 'одбојка', 'малине', 'енглески', 'руски'},
        'Љубица': {'Ужице', 'клавир', 'кошарка', 'салата', 'енглески'},
        'Јован': {'Шабац', 'виолина', 'рукомет', 'сарма', 'шпански', 'енглески'}
    }

    tagovi = input('Наведите појмове који вас интерсују раздвојене зарезима: ').split(',')
    tagovi = {tag.strip() for tag in tagovi}
    poklapanje = {osoba : len(tagovi & tagovi_za_osobu[osoba]) for osoba in tagovi_za_osobu.keys()}
    osobe_po_stepenu_poklapanja = sorted(poklapanje.items(), key = lambda x: -x[1])
    for osoba, broj_poklapanja in osobe_po_stepenu_poklapanja:
        print(osoba, broj_poklapanja)


